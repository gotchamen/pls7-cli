# pls7-cli

A simple CLI for Pot Limit Sampyong 7 or Better (PLS7) Poker

## What is PLS7?

https://philipjkim.github.io/posts/20250724-sampyeong-holdem-guide-v1-4/

## Installation

TODO

## 📝 점진적 개발 계획 (Step-by-Step)

### **1단계: 프로젝트 뼈대 구축 (Cobra & 디렉토리)**

* **목표**: 명령어로 실행 가능한 가장 기본적인 "Hello World" 앱 만들기.
* **주요 작업**:
    1.  설계한 **디렉토리 구조**(`cmd`, `internal`, `pkg`)를 생성합니다.
    2.  `go mod init`으로 Go 모듈을 초기화합니다.
    3.  `Cobra` 라이브러리를 설치합니다.
    4.  `cmd/root.go`와 `cmd/play.go`를 생성합니다.
    5.  `play` 명령어 실행 시 "삼평 홀덤 게임을 시작합니다!"라는 문구만 출력하도록 구현합니다.
* **결과물**: `go run main.go play` 명령어를 터미널에 입력하면 환영 메시지가 출력되는, 뼈대만 갖춘 CLI 애플리케이션.

완료여부: [x]

---

### **2단계: 기본 데이터 모델 구현 (Card & Deck)**

* **목표**: 카드와 덱을 코드로 구현하고, 셔플된 덱을 화면에 출력하기.
* **주요 작업**:
    1.  `pkg/poker/card.go`에 `Card`, `Suit`, `Rank` 구조체를 정의합니다.
    2.  `pkg/poker/deck.go`에 `Deck` 구조체와 `NewDeck()`, `Shuffle()`, `Deal()` 메소드를 구현합니다.
    3.  `cmd/play.go`에서 `NewDeck()`을 호출하여 덱을 만들고, `Shuffle()`로 섞은 뒤, `Deal()`로 5장을 뽑아 화면에 **단순 출력(print)**합니다.
* **결과물**: 실행할 때마다 무작위로 섞인 카드 5장이 화면에 출력되는 앱.

완료여부: [x]

---

### **3단계: 정적(Static) 핸드 시뮬레이션**

* **목표**: 게임 흐름 없이, 카드 분배가 완료된 한순간의 테이블 상황을 화면에 보여주기.
* **주요 작업**:
    1.  `Player`와 `Game` 구조체의 기본 형태를 만듭니다. (이름, 카드 패 등 최소한의 정보만 포함)
    2.  `cmd/play.go`에서 **하드코딩**으로 게임을 설정합니다.
        * 플레이어 1명과 CPU 5명을 생성합니다.
        * 덱에서 각 플레이어에게 카드 3장, 커뮤니티 카드로 5장을 분배합니다.
    3.  `internal/cli/display.go`에 이 정적인 게임 상태를 **단순 출력**하는 **모의(mock) 함수**를 만듭니다.
* **결과물**: 6명의 플레이어 패와 커뮤니티 카드가 모두 깔린, 한 판의 정지된 스냅샷이 화면에 출력되는 앱.

완료여부: [ ]

---

### **4단계: 족보 판정 로직 구현 및 테스트**

* **목표**: 가장 복잡한 족보 판정 로직을 **단위 테스트**를 통해 독립적으로 완성하기.
* **주요 작업**:
    1.  `pkg/poker/evaluation.go`에 `EvaluateHands` 함수와 관련 로직을 구현합니다.
    2.  이전에 정의한 **테스트 스펙**에 따라 단위 테스트(`_test.go`)를 작성합니다.
    3.  **원 페어, 투 페어** 등 간단한 족보부터 하나씩 구현하고 테스트를 통과시킵니다.
    4.  **쿼드 페어, 스킵 스트레이트** 등 모든 특수 족보와 엣지 케이스에 대한 테스트를 통과할 때까지 로직을 완성합니다.
    5.  3단계의 결과물에 족보 판정 로직을 붙여, 각 플레이어가 최종적으로 어떤 족보를 가졌는지 출력합니다.
* **결과물**: 정적 핸드 상황을 보여주고, 각 플레이어의 최종 족보(예: "Player: 풀하우스", "CPU 3: 7-하이 로우")를 정확히 계산하여 알려주는 앱.

완료여부: [ ]

---

### **5단계: 자동 게임 흐름 구현**

* **목표**: 사용자 입력 없이, 한 핸드가 자동으로 진행되는 '시네마틱 모드' 구현하기.
* **주요 작업**:
    1.  `internal/game/game.go`에 **메인 게임 루프**를 구현합니다.
    2.  루프는 프리플랍 → 플랍 → 턴 → 리버 순서로 진행됩니다.
    3.  각 단계마다 `time.Sleep()`으로 잠시 멈추고, `cli`의 출력 함수를 호출하여 현재 상태를 보여줍니다.
    4.  베팅 로직은 **모의 처리**합니다. (예: 모든 플레이어는 `체크` 또는 `콜`만 한다고 가정)
* **결과물**: 실행하면 프리플랍부터 리버까지 카드 깔리는 과정이 순차적으로 보이고, 쇼다운 후 결과가 출력되는, 한 편의 영화처럼 자동으로 진행되는 게임.

완료여부: [ ]

---

### **6단계: 사용자 입력 및 기본 액션 처리**

* **목표**: 플레이어가 직접 자신의 턴에 명령어를 입력하고, 게임이 그에 반응하게 하기.
* **주요 작업**:
    1.  `internal/cli/input.go`에 사용자 입력을 받는 프롬프트 로직을 구현합니다.
    2.  게임 루프에서 **플레이어의 턴**이 되면, 루프를 멈추고 입력을 기다립니다.
    3.  `f`(폴드)를 입력하면 플레이어의 상태를 `Folded`로 바꾸고, `c`(콜)를 입력하면 다음 단계로 넘어가는 등 **기본적인 액션 처리 로직**을 추가합니다.
    4.  CPU 턴은 여전히 `체크` 또는 `폴드`만 하는 단순한 로직으로 둡니다.
* **결과물**: 사용자가 직접 참여하여 간단한 액션을 취할 수 있는, 최초의 **플레이 가능한 버전**.

완료여부: [ ]

---

### **7단계 이후: 전체 기능 완성**

* **목표**: 나머지 기능들을 하나씩 추가하며 완전한 게임으로 발전시키기.
* **주요 작업**:
    * **베팅/팟 로직**: 팟 리밋 규칙에 따른 베팅, 레이즈, 팟 계산 로직을 완성합니다.
    * **CPU AI**: 정의한 난이도별(Easy, Medium, Hard) AI 로직을 구현합니다.
    * **전체 완성**: 블라인드, 칩 관리, 게임 오버 조건 등 나머지 모든 기능을 통합합니다.
    * **리팩토링**: 코드 가독성을 높이고 구조를 개선합니다.

완료여부: [ ]
