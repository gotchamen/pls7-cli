## 질문 1

combinations.go 의 L12-14 를 보면 len(pool) < n 일 때 비정상 조건으로 판단해서 nil 을 리턴하는데, nil 대신 empty slice 인 [][]Card{{}} 을 리턴하면 NPE 에러를 막을 수 있지 않아? 굳이 nil 을 리턴하는 의도가 있어?

```go
if len(pool) < n {
    return nil
}
```

## 답변 1

좋은 질문입니다. NPE(Nil Pointer Exception)에 대한 우려는 매우 중요하며, 코드의 안정성을 위해 항상 고려해야 할 부분입니다.

len(pool) < n일 때 nil을 반환하는 것은 의도된 동작이며, 그 이유는 다음과 같습니다.

1. 의미의 명확성: combinations 함수의 반환 값은 '찾아낸 모든 조합의 목록'입니다.
    * len(pool) < n인 경우, n개의 카드를 뽑는 조합은 물리적으로 불가능합니다. 즉, 가능한 조합의 개수는 0개입니다.
    * Go에서 '결과 없음' 또는 '비어 있는 슬라이스'를 나타내는 가장 일반적이고 관용적인 방법은 nil 슬라이스입니다. len(nil)은 0이므로, for...range 구문으로 반복해도 아무 문제 없이 안전하게 동작합니다.
    * 반면, 제안해주신 [][]Card{{}}는 "비어 있는 조합 1개"를 의미합니다. 이는 n=0일 때(0개의 카드를 뽑는 조합은 '아무것도 뽑지 않는' 1가지 경우가 존재) 반환되는 값으로, len(pool) < n의 경우와는 의미가 다릅니다.

2. Go의 관용적 표현(Idiomatic Go): Go에서는 결과가 없는 슬라이스를 반환할 때 nil을 사용하는 것이 매우 일반적입니다. 이는 불필요한 메모리 할당을 피하는 효과도 있습니다. 표준 라이브러리를 포함한 많은 Go 코드에서 이러한 패턴을 발견할 수 있습니다.

결론적으로, nil을 반환하는 것은 '가능한 조합이 없으므로 빈 목록을 반환한다'는 명확한 의미를 가지며, Go의 관용적인 표현에 부합합니다. for...range 루프 등 일반적인 사용 사례에서 NPE를 유발하지 않으므로 안전하게 사용할 수 있습니다.

---

## 질문 2

combination_test.go 에 추가된 init 함수의 영향범위는 동일한 파일 내에 있는 함수들까지야, 아니면 poker 패키지 전체에 영향을 미쳐? init 함수의 동작원리를 자세히 설명해줘.

```go
func init() {
    logrus.SetLevel(logrus.DebugLevel)
}
```

## 답변 2

좋은 질문입니다. init 함수의 동작 원리와 영향 범위를 이해하는 것은 Go 언어에서 매우 중요합니다.

결론부터 말씀드리면, combinations_test.go에 추가된 init 함수는 `poker` 패키지 전체에 영향을 미칩니다.

init 함수의 동작 원리를 자세히 설명해 드리겠습니다.

### init 함수란?

init 함수는 Go 프로그램의 패키지가 초기화될 때 시스템에 의해 자동으로 실행되는 특별한 함수입니다. 인자나 반환값이 없으며, 코드에서 직접 호출할 수 없습니다.

```go
func init() {
    // 패키지 초기화 코드
}
```

### init 함수의 실행 시점과 순서

1. 패키지 Import: 프로그램에서 특정 패키지를 import하면, Go 런타임은 해당 패키지의 init 함수를 실행합니다.
2. 의존성 우선: 만약 A 패키지가 B 패키지를 import한다면, B 패키지의 init 함수가 A 패키지의 init 함수보다 반드시 먼저 실행됩니다.
3. 동일 패키지 내 실행 순서:
    * 하나의 패키지 안에 여러 개의 init 함수가 존재할 수 있습니다 (여러 파일에 나뉘어 있거나, 한 파일에 여러 개 있을 수도 있습니다).
    * Go 컴파일러는 해당 패키지에 속한 모든 .go 파일들을 파일 이름의 알파벳 순서대로 처리합니다.
    * 컴파일러는 각 파일 내에서 init 함수가 나타나는 순서대로 실행 계획을 세웁니다.
    * 결론적으로, 동일 패키지 내의 init 함수들은 파일 이름 순 -> 파일 내 코드 순서에 따라 순차적으로 실행됩니다.

### go test 와 init 함수

go test ./pkg/poker 명령을 실행하면, Go 컴파일러는 pkg/poker 디렉토리 안에 있는 모든 .go 파일과 _test.go 파일들을 묶어 하나의 임시 테스트용 패키지를 만듭니다.

제가 추가한 combinations_test.go 파일은 package poker로 선언되어 있으므로, 이 파일은 테스트 실행 시 poker 패키지의 일부가 됩니다.

따라서, 테스트가 시작되기 전에 Go 런타임은 poker 패키지를 초기화하면서 combinations_test.go 파일 안에 있는 init 함수를 실행합니다.

### 결론: init 함수의 영향 범위

init 함수 내에서 실행한 logrus.SetLevel(logrus.DebugLevel) 코드는 logrus 라이브러리의 전역(Global) 로그 레벨을 변경하는 것입니다.

따라서 init 함수가 실행된 이후부터는, 해당 테스트 프로그램이 끝날 때까지 poker 패키지 내의 다른 어떤 파일(evaluation.go, deck.go 등)에서 logrus를 사용하더라도 모두 Debug 레벨이 적용됩니다. 즉, 영향 범위는 파일 하나에 국한되지 않고 패키지 전체입니다.

---

## 질문 3

evaluation.go L229-251 을 보니, 인터페이스를 하나 정의하고 gameRules.HoleCards.UseConstraint 에 따라 그에 맞는 all5CardCombos slice 값을 리턴하는 구현체를 만들어 사용하면 코드 가독성이 더 올라갈 것 같은데 너의 생각은 어때?

## 답변 3

매우 좋은 제안입니다. 코드 가독성과 확장성을 크게 높일 수 있는 훌륭한 리팩토링 아이디어라고 생각합니다.

말씀하신 대로, UseConstraint 값에 따라 조합 생성 로직을 선택하는 부분을 전략 패턴(Strategy Pattern)을 적용하여 추상화하면 다음과 같은 장점이 있습니다.

1. 가독성 향상: EvaluateHand 함수는 "어떤 전략을 사용해 카드 조합을 생성하고, 각 조합을 평가하여 최고를 가린다"는 핵심 흐름만 남게 되어 훨씬 이해하기 쉬워집니다. 복잡한 if/else 분기문이 사라지기 때문입니다.
2. 개방-폐쇄 원칙(OCP) 준수: 나중에 "최대 2장 사용"과 같은 새로운 홀카드 사용 규칙이 추가되더라도, EvaluateHand 함수 자체를 수정할 필요 없이 새로운 전략 구현체만 추가하면 됩니다. 이는 코드 변경을 최소화하여 버그 발생 가능성을 줄입니다.
3. 책임 분리: 핸드 평가 로직과 카드 조합 생성 로직의 책임이 명확하게 분리됩니다.

제안해주신 방향에 맞춰 리팩토링을 진행하겠습니다.

리팩토링 계획:

1. 카드 조합을 생성하는 로직의 인터페이스(HandCombinationGenerator)를 정의합니다.
2. "exact"와 "any" 제약 조건에 맞는 구체적인 구현체(ExactCombinationGenerator, AnyCombinationGenerator)를 만듭니다.
3. EvaluateHand 함수가 이 인터페이스를 사용하도록 구조를 변경합니다.
