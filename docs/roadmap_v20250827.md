## 개발 로드맵 (2025-08-27 기준)

이 로드맵은 다른 개발자들과 함께 좀더 효과적인 논의를 하기 위해 만들어졌으며, 모두 공감하는 단계들은 추후 development_plan.md 에 반영될 예정입니다.

### 1단계: 기존 CLI 애플리케이션 강화 (Quick Wins)

CLI 환경에서 즉각적으로 체감할 수 있는 개선 사항들을 우선적으로 적용합니다.

1. 최초 칩, 블라인드 설정 기능 구현
    * 목표: 사용자가 게임 시작 시 초기 칩과 스몰/빅 블라인드 금액을 직접 설정할 수 있도록 합니다.
    * 구현 아이디어:
        * cmd/root.go에 --chips, --sb, --bb와 같은 Cobra CLI 플래그 추가
        * game.NewGame 생성자에서 해당 플래그 값을 받아 Game 및 Player 구조체 초기화 시 반영

2. 게임 상태 저장 및 불러오기 기능 구현
    * 목표: 현재 게임 상태를 파일로 저장하고, 나중에 이어서 할 수 있는 기능을 추가합니다.
    * 구현 아이디어:
        * save, load 와 같은 새로운 Cobra 서브 커맨드 추가
        * game.Game 구조체 전체를 JSON 형식으로 직렬화(Marshal)하여 파일에 저장
        * 저장된 JSON 파일을 읽어 game.Game 구조체로 역직렬화(Unmarshal)하여 게임 상태 복원

### 2단계: CLI 멀티플레이어 구현 (TCP 소켓)

서버-클라이언트 구조를 도입하여 터미널 환경에서 여러 사용자가 함께 플레이할 수 있도록 지원합니다.

3. TCP 기반 멀티플레이어 기능 구현
    * 목표: 여러 사용자가 각자의 CLI 환경에서 하나의 게임 서버에 접속하여 실시간으로 포커를 즐길 수 있도록 합니다.
    * 구현 아이디어:
        * 서버(Server) 개발:
            * 게임 상태(game.Game)를 중앙에서 관리하고, 전체 게임 로직을 실행하는 독립적인 서버 애플리케이션을 만듭니다.
            * net 패키지를 사용하여 특정 포트에서 TCP 연결을 수신(Listen)합니다.
            * 각 클라이언트 연결을 별도의 고루틴(Goroutine)으로 처리하여 동시성을 확보합니다.
        * 클라이언트(Client) 수정:
            * 기존 pls7 CLI에 --join <ip:port> 와 같은 플래그를 추가하여 클라이언트 모드로 동작하도록 수정합니다.
            * 서버에 TCP 소켓으로 연결하고, 서버로부터 받은 게임 상태 데이터를 화면에 렌더링합니다.
            * 자신의 턴이 되면 사용자 입력을 받아 서버로 전송합니다.
        * 통신 프로토콜 정의:
            * 서버와 클라이언트가 주고받을 메시지 형식을 정의합니다. (예: JSON 기반의 텍스트 프로토콜)
            * {"type": "gameState", "data": ...} (서버 -> 클라)
            * {"type": "playerAction", "action": "bet", "amount": 100} (클라 -> 서버)

### 3단계: 웹 애플리케이션 전환을 위한 기반 구축

장기적인 목표인 웹 서비스로 나아가기 위한 기술적 토대를 마련합니다.

4. CI/CD 파이프라인 구축 및 고도화 (추가 제안)
    * 목표: 코드 변경 시 자동으로 테스트, 빌드, 배포하는 과정을 자동화하여 안정성을 높입니다.
    * 구현 아이디어:
        * 기존 .github/workflows/go.yml 확장
        * go test -race ./... 와 같이 경쟁 상태(race condition)를 검출하는 테스트 스텝 추가
        * 빌드 아티팩트(실행 파일)를 GitHub Release에 자동으로 업로드하는 스텝 추가
        * (5단계 이후) API 서버의 Docker 이미지를 빌드하고 Docker Hub 또는 GHCR에 푸시하는 스텝 추가

5. HTTP API 서버 기본 골격 구현
    * 목표: 게임의 핵심 로직을 제어할 수 있는 RESTful API 서버를 구축합니다.
    * 구현 아이디어:
        * net/http 표준 패키지 또는 Gin, Echo 같은 경량 웹 프레임워크를 사용하여 서버 설정
        * poker-engine 모듈을 재사용하여 게임 로직 처리
        * API 엔드포인트 정의:
            * POST /games: 새 게임 생성
            * GET /games/{id}: 특정 게임 상태 조회
            * POST /games/{id}/actions: 플레이어 액션(벳, 콜, 폴드 등) 전송

### 4단계: 웹 애플리케이션 기능 구현

사용자에게 웹을 통해 포커 게임 경험을 제공합니다.

6. 사용자 인증(OAuth2) 및 세션 관리 기능 구현
    * 목표: 외부 서비스(Google, GitHub 등) 계정으로 로그인하고, 로그인 상태를 유지하는 기능을 구현합니다.
    * 구현 아이디어:
        * golang.org/x/oauth2 패키지를 활용하여 OAuth2 클라이언트 구현
        * 로그인 성공 후, JWT(JSON Web Token)를 발급하여 클라이언트에게 전달
        * API 요청 시 JWT를 검증하여 사용자 인증 처리

7. Vue.js 기반 프론트엔드 개발
    * 목표: API 서버와 통신하며 사용자가 게임을 즐길 수 있는 동적인 웹 UI를 개발합니다.
    * 구현 아이디어:
        * Vue.js 또는 Nuxt.js 프로젝트 생성
        * axios를 사용하여 API 서버와 비동기 통신
        * 게임 테이블, 플레이어 카드, 칩, 액션 버튼 등 컴포넌트 기반으로 UI 설계
        * Pinia 또는 Vuex를 이용한 상태 관리
        * Vercel, Netlify 등을 통한 정적 사이트 배포 설정

### 5단계: 서비스 고도화

사용자 경험을 향상시키고 더 많은 기능을 제공합니다.

8. 실시간 게임 경험을 위한 WebSocket 도입 (추가 제안)
    * 목표: 다른 플레이어의 액션이나 게임 상태 변경을 페이지 새로고침 없이 모든 클라이언트에게 실시간으로 전송합니다.
    * 구현 아이디어:
        * API 서버에 WebSocket 핸들러 추가
        * 게임 상태에 변경이 생길 때마다 해당 게임에 연결된 모든 클라이언트에게 업데이트된 상태 브로드캐스팅
        * 프론트엔드에서 WebSocket 연결을 수신하여 UI를 동적으로 업데이트

9. 다양한 게임 룰 추가 및 관리 기능 (추가 제안)
    * 목표: rules 디렉토리의 YAML 파일을 웹 UI에서 관리하고, 사용자가 원하는 룰의 게임을 생성할 수 있도록 합니다.
    * 구현 아이디어:
        * 게임 룰 목록을 제공하는 API 엔드포인트 추가
        * 사용자가 게임 생성 시 룰을 선택할 수 있는 UI 제공
